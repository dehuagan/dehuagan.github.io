# redis为啥快
> redis是单线程的多路复用IO，单线程避免了线程切换的开销，而多路复用避免了IO等待的开销

> redis6.0引入了多线程，但是，需要提醒大家的是，Redis 6.0中的多线程，也只是针对处理网络请求过程采用了多线程，而数据的读写命令，仍然是单线程处理的。
>
> 在多路复用的IO模型中，在处理网络请求时，调用 select （其他函数同理）的过程是阻塞的，也就是说这个过程会阻塞线程，如果并发量很高，此处可能会成为瓶颈。
>
> 如果能采用多线程，使得网络处理的请求并发进行，就可以大大的提升性能。多线程除了可以减少由于网络 I/O 等待造成的影响，还可以充分利用 CPU 的多核优势。

### 一、 如何解决缓存雪崩
#### 什么是缓存雪崩
> - Redis挂掉了，请求全部走数据库
> - 对缓存数据设置相同的过期时间（不可能把所有的数据都缓存起来(内存昂贵且有限)），导致某段时间内缓存失效，请求全部走数据库

#### 解决方法：
对于“对缓存数据设置相同的过期时间，导致某段时间内缓存失效，请求全部走数据库。”这种情况，非常好解决：
> 在缓存的时候给过期时间加上一个随机值，这样就会大幅度的减少缓存在同一时间过期。

对于“Redis挂掉了，请求全部走数据库”这种情况，我们可以有以下的思路
> - 事发前：实现Redis的高可用(主从架构+Sentinel 或者Redis Cluster)，尽量避免Redis挂掉这种情况发生。
> - 事发中：万一Redis真的挂了，我们可以设置本地缓存(ehcache)+限流(hystrix)，尽量避免我们的数据库被干掉(起码能保证我们的服务还是能正常工作的)
> - 事发后：redis持久化，重启后自动从磁盘上加载数据，快速恢复缓存数据。
### 二、缓存穿透
#### 是什么
> 缓存穿透是指查询一个一定不存在的数据。由于缓存不命中，并且出于容错考虑，如果从数据库查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，失去了缓存的意义
#### 解决方案：
> - 由于请求的参数是不合法的(每次都请求不存在的参数)，于是我们可以使用布隆过滤器(BloomFilter)或者压缩filter提前拦截，不合法就不让这个请求到数据库层！
> - 当我们从数据库找不到的时候，我们也将这个空对象设置到缓存里边去。下次再请求的时候，就可以从缓存里边获取了。
> 这种情况我们一般会将空对象设置一个较短的过期时间。

### 三、缓存与数据库双写一致
#### 读操作流程
> - 如果我们的数据在缓存里边有，那么就直接取缓存的。
> - 如果缓存里没有我们想要的数据，我们会先去查询数据库，然后将数据库查出来的数据写到缓存中。
> - 最后将数据返回给请求

#### 缓存与数据库双写一致问题
> 当我们要更新时候, 各种情况很可能就造成数据库和缓存的数据不一致了

#### 解决方案
- 先删除缓存，再更新数据库
(1. 删除缓存直接和简单很多，2. 体现懒加载，所以应该删除缓存而不是更新缓存)
> 1. 如果原子性被破坏：
> - 第一步成功(删除缓存)，第二步失败(更新数据库)，数据库和缓存的数据还是一致的。
> - 如果第一步(删除缓存)就失败了，我们可以直接返回错误(Exception)，数据库和缓存的数据还是一致的。
> 2. 高并发下
> - 线程A删除了缓存
> - 线程B查询，发现缓存已不存在
> - 线程B去数据库查询得到旧值
> - 线程B将旧值写入缓存
> - 线程A将新值写入数据库
>
> 总结：
> 在高并发下表现不如意，在原子性被破坏时表现优异

- 先更新数据库，再删除缓存(Cache Aside Pattern设计模式)
> 1. 如果原子性被破坏了：
> - 第一步成功(操作数据库)，第二步失败(删除缓存)，会导致数据库里是新数据，而缓存里是旧数据。
> - 如果第一步(操作数据库)就失败了，我们可以直接返回错误(Exception)，不会出现数据不一致。
> 2. 高并发下
> - 缓存刚好失效
> - 线程A查询数据库，得一个旧值
> - 线程B将新值写入数据库
> - 线程B删除缓存
> - 线程A将查到的旧值写入缓存

>总结：
>  在高并发下表现优异，在原子性被破坏时表现不如意

### 四、主从复制流程
> 1. slave节点接受slaveof命令，向master发起tcp连接
> 2. master与slave(此时只认为是一个普通的client)端建立tcp连接
> 3. client发送PING命令，确认对方是一个redis实例
> 4. master响应PING命令并发送PONG回复表示master OK
> 5. slave(此时认为是一个slave节点了)发送SYNC同步命令
> 6. master把slae添加进slave列表，并启动一个子线程保存RDB文件，当RDB文件保存成功时，向所有slave发送数据

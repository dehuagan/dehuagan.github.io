#





[详细](https://mp.weixin.qq.com/s/J3kCOJwyv2nzvI0_X0tlnA)


# 索引
## 磁盘IO与预读
磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为<font color=green>寻到时间、旋转延迟、传输时间</font>三个部分。

寻道时间指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在5ms以下；

旋转延迟就是我们经常听说的磁盘转速，比如一个磁盘7200转，表示每分钟能转7200次，也就是说1秒钟能转120次，旋转延迟就是1/120/2=4.17ms；

传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。

那么访问一次磁盘的时间，即一次磁盘IO的时间约等于5+4.17=9ms。

## 索引的优势
- 可以提高数据检索的效率，降低数据库的IO成本。
- 通过索引列对数据进行排序，降低数据排序成本，降低CPU消耗。

## 索引的劣势
- 索引会占据磁盘空间
- 索引虽然提高查询效率，但是会降低更新表的效率。比如每次对表进行增删改操作，MySQL不仅要保存数据，还有保存或者更新对应的索引文件。（比如在B+树种需要对树进行分裂、合并、旋转等操作来维护平衡性。）

# B+树索引
![img](../img/b+树.png)

## 结构
多叉平衡树，只有叶子节点才会存放数据，非叶子结点只存储指引搜索方向的数据项，叶子节点之间使用双向指针连接，最底层的叶子节点形成了一个双向有序链表。

IO（把磁盘块/数据页由磁盘加载到内存）次数取决于B+树的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有 <font color=green>**h = log(m+1)N**</font>，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块大小/数据项的大小，磁盘块的大小也就是数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。
## 查询操作
首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。

插入删除操作会破坏平衡树的平衡性，因此在进行插入删除操作之后，需要对树进行分裂、合并、旋转等操作来维护平衡性。

## B + 树与红黑树的比较

红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因：

（一）磁盘 IO 次数

B+ 树一个节点可以存储多个元素，相对于红黑树（出度为2）的树高更低，磁盘 IO 次数更少。

（二）磁盘预读特性

为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道。每次会读取页的整数倍。

操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。


## B + 树与 B 树的比较

### B+ 树的磁盘 IO 更低

B+ 树的内部节点并没有指向关键字具体信息的指针。因此其内部节点相对 B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。

### B+ 树的查询效率更加稳定

由于非叶子结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

### B+ 树元素遍历效率高

B 树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而 B 树不支持这样的操作（或者说效率太低）。




# 创建索引语句
CREATE INDEX indexName ON table_name (column_name)

left join语句

 MySQL LEFT JOIN 会读取左边数据表的全部数据，即便右边表无对应数据。
```
select a.x from a left join b on a.x=b.x;
```


# MVCC
MVCC是多版本并发控制，通过回滚指针把一个数据行的所有快照连接起来，存储在undo log里，在一个事务读取数据行的时候，只能读取版本号小于等于当前事务版本号的数据行。

# 数据库优化
[详细](https://mp.weixin.qq.com/s/e0CqJG2-PCDgKLjQfh02tw)

## 在本地环境跑一遍SQL，但是要排除缓存干扰，执行SQL的时候，记得加上SQL NoCache去跑SQL
> 如果我们当前的MySQL版本支持缓存而且我们又开启了缓存，那每次请求的查询语句和结果都会以key-value的形式缓存在内存中的，大家也看到我们的结构图了，一个请求会先去看缓存是否存在，不存在才会走解析器。
>
> 但是，缓存会经常失败
>
> 缓存失效比较频繁的原因就是，只要我们一对表进行更新，那这个表所有的缓存都会被清空，其实我们很少存在不更新的表，特别是我之前的电商场景，可能静态表可以用到缓存，但是我们都走大数据离线分析，缓存也就没用了。

## explain
explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。

### select_type
常用的有 SIMPLE 简单查询，UNION 联合查询，SUBQUERY 子查询等。

### table
要查询的表

### possible_keys
可能选择的索引

### key
实际使用的索引

### rows
扫描的行数

### type

#### system
触发条件：表只有一行，这是一个 const type 的特殊情况

#### const
触发条件：在使用主键或者唯一索引进行查询的时候只有一行匹配。

#### eq_ref
触发条件：在进行联接查询的，使用主键或者唯一索引并且只匹配到一行记录的时候

![img](../img/eq_ref.png)

#### ref
触发条件：使用非唯一索引

#### range
触发条件：只有在使用主键、单个字段的辅助索引、多个字段的辅助索引的最后一个字段进行范围查询才是 range

![img](../img/range.png)

#### index
触发条件：

只扫描索引树

1）查询的字段是索引的一部分，覆盖索引。2）使用主键进行排序

#### all
触发条件：全表扫描，不走索引

#### 覆盖索引
#### 联合索引

### 一条sql语句执行很慢的原因
大多数情况是正常的，只是偶尔很慢
>  数据库在刷新脏页（flush）：往数据库插入或更新一条数据的时候，数据库会在内存中把数据更新，但是不会马上同步持久化到磁盘中，而是写入redo log里，等到空闲的时候再通过redo log把数据同步到磁盘中。当内存数据页和磁盘数据页内容不一致的时候，称这个内存页为“脏页”，内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”。如果redo log满了，就不能等到空闲再把数据同步到磁盘，只能暂停其它操作，全身心把数据同步到磁盘中去，这时就会导致sql执行很慢

一直很慢
> 没有用索引

### SELECT COUNT(*)的一些问题：
[详细](https://mp.weixin.qq.com/s/SNRvdmyS57oWS_CyYKVvSA)


# 解释一下什么是池化设计思想。什么是数据库连接池?为什么需要数据库连接池?

池化设计应该不是一个新名词。我们常⻅的如java线程池、jdbc连接池、redis连接池等就是这类设计 的代表实现。这种设计会初始预设资源，解决的问题就是抵消每次获取资源的消耗，如创建线程的开 销，获取远程连接的开销等。就好比你去⻝堂打饭，打饭的大妈会先把饭盛好几份放那里，你来了就直 接拿着饭盒加菜即可，不用再临时又盛饭又打菜，效率就高了。除了初始化资源，池化设计还包括如下 这些特征:池子的初始值、池子的活跃值、池子的最大值等，这些特征可以直接映射到java线程池和数 据库连接池的成员属性中。

数据库连接本质就是一个 socket 的连接。数据库服务端还要维护一些缓存和用户权限信息之类的 所 以占用了一些内存。我们可以把数据库连接池是看做是维护的数据库连接的缓存，以便将来需要对数据 库的请求时可以重用这些连接。为每个用户打开和维护数据库连接，尤其是对动态数据库驱动的网站应 用程序的请求，既昂贵又浪费资源。在连接池中，创建连接后，将其放置在池中，并再次使用它，因此 不必建立新的连接。如果使用了所有连接，则会建立一个新连接并将其添加到池中。 连接池还减少了 用户必须等待建立与数据库的连接的时间。
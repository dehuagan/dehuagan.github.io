#





[详细](https://mp.weixin.qq.com/s/J3kCOJwyv2nzvI0_X0tlnA)


# 索引
## 磁盘IO与预读
磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为<font color=green>寻到时间、旋转延迟、传输时间</font>三个部分。

寻道时间指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在5ms以下；

旋转延迟就是我们经常听说的磁盘转速，比如一个磁盘7200转，表示每分钟能转7200次，也就是说1秒钟能转120次，旋转延迟就是1/120/2=4.17ms；

传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。

那么访问一次磁盘的时间，即一次磁盘IO的时间约等于5+4.17=9ms。

## 索引的优势
- 可以提高数据检索的效率，降低数据库的IO成本。
- 通过索引列对数据进行排序，降低数据排序成本，降低CPU消耗。

## 索引的劣势
- 索引会占据磁盘空间
- 索引虽然提高查询效率，但是会降低更新表的效率。比如每次对表进行增删改操作，MySQL不仅要保存数据，还有保存或者更新对应的索引文件。（比如在B+树种需要对树进行分裂、合并、旋转等操作来维护平衡性。）

# B+树索引
![img](../img/b+树.png)

## 结构
多叉平衡树，只有叶子节点才会存放数据，非叶子结点只存储指引搜索方向的数据项，叶子节点之间使用双向指针连接，最底层的叶子节点形成了一个双向有序链表。

IO（把磁盘块/数据页由磁盘加载到内存）次数取决于B+树的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有 <font color=green>**h = log(m+1)N**</font>，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块大小/数据项的大小，磁盘块的大小也就是数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。
## 查询操作
首先在根节点进行二分查找，找到



创建索引语句
CREATE INDEX indexName ON table_name (column_name)

left join语句

 MySQL LEFT JOIN 会读取左边数据表的全部数据，即便右边表无对应数据。
```
select a.x from a left join b on a.x=b.x;
```


# MVCC
MVCC是多版本并发控制，通过回滚指针把一个数据行的所有快照连接起来，存储在undo log里，在一个事务读取数据行的时候，只能读取版本号小于等于当前事务版本号的数据行。

# 数据库优化
[详细](https://mp.weixin.qq.com/s/e0CqJG2-PCDgKLjQfh02tw)

## 在本地环境跑一遍SQL，但是要排除缓存干扰，执行SQL的时候，记得加上SQL NoCache去跑SQL
> 如果我们当前的MySQL版本支持缓存而且我们又开启了缓存，那每次请求的查询语句和结果都会以key-value的形式缓存在内存中的，大家也看到我们的结构图了，一个请求会先去看缓存是否存在，不存在才会走解析器。
>
> 但是，缓存会经常失败
>
> 缓存失效比较频繁的原因就是，只要我们一对表进行更新，那这个表所有的缓存都会被清空，其实我们很少存在不更新的表，特别是我之前的电商场景，可能静态表可以用到缓存，但是我们都走大数据离线分析，缓存也就没用了。

## explain
explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。

### select_type
常用的有 SIMPLE 简单查询，UNION 联合查询，SUBQUERY 子查询等。

### table
要查询的表

### possible_keys
可能选择的索引

### key
实际使用的索引

### rows
扫描的行数

### type

#### system
触发条件：表只有一行，这是一个 const type 的特殊情况

#### const
触发条件：在使用主键或者唯一索引进行查询的时候只有一行匹配。

#### eq_ref
触发条件：在进行联接查询的，使用主键或者唯一索引并且只匹配到一行记录的时候

![img](../img/eq_ref.png)

#### ref
触发条件：使用非唯一索引

#### range
触发条件：只有在使用主键、单个字段的辅助索引、多个字段的辅助索引的最后一个字段进行范围查询才是 range

![img](../img/range.png)

#### index
触发条件：

只扫描索引树

1）查询的字段是索引的一部分，覆盖索引。2）使用主键进行排序

#### all
触发条件：全表扫描，不走索引

#### 覆盖索引
#### 联合索引

### 一条sql语句执行很慢的原因
大多数情况是正常的，只是偶尔很慢
>  数据库在刷新脏页（flush）：往数据库插入或更新一条数据的时候，数据库会在内存中把数据更新，但是不会马上同步持久化到磁盘中，而是写入redo log里，等到空闲的时候再通过redo log把数据同步到磁盘中。当内存数据页和磁盘数据页内容不一致的时候，称这个内存页为“脏页”，内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”。如果redo log满了，就不能等到空闲再把数据同步到磁盘，只能暂停其它操作，全身心把数据同步到磁盘中去，这时就会导致sql执行很慢

一直很慢
> 没有用索引

### SELECT COUNT(*)的一些问题：
[详细](https://mp.weixin.qq.com/s/SNRvdmyS57oWS_CyYKVvSA)

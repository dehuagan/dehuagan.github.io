# 面向对象7大原则
[详细](https://blog.csdn.net/J080624/article/details/84930351)
1. 单一职责原则
> 每个类（接口）应该专注于做一件事，常常可见接口多继承现象。
2. 里氏替换原则
> 超类存在的地方，子类是可替换的。里氏替换原则告诉我们，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立。如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。
里氏替换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。
3. 依赖倒置原则
> 实现尽量依赖抽象(抽象类或者接口)，不依赖具体实现。
4. 接口隔离原则
> 每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。
5. 迪米特法则
> 又叫最少知道原则，一个软件实体应当尽可能少的与其他实体发生相互作用。
6. 开闭原则
> 软件实体面向扩展开放，面向修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类等。
7. 聚合复用原则
> 尽量使用合成/聚合达到复用，尽量少用继承。原则： 一个类中有另一个类的对象。即多用组合，少用继承。


# 零拷贝
## 总结
>传统 IO 的工作方式，从硬盘读取数据，然后再通过网卡向外发送，我们需要进行 4 次上下文切换，和 4 次数据拷贝，其中 2次数据拷贝发生在内存里的缓冲区和对应的硬件设备之间，这个是由 DMA 完成，另外 2 次则发生在内核态和用户态之间，这个数据搬移工作是由 CPU 完成的。
>
>为了提高文件传输的性能，于是就出现了零拷贝技术，它通过一次系统调用（sendfile 方法）合并了磁盘读取与网络发送两个操作，降低了上下文切换次数。另外，拷贝数据都是发生在内核中的，天然就降低了数据拷贝的次数。
>
>Kafka 和 Nginx 都有实现零拷贝技术，这将大大提高文件传输的性能。
>
>零拷贝技术是基于 PageCache 的，PageCache 会缓存最近访问的数据，提升了访问缓存数据的性能，同时，为了解决机械硬盘寻址慢的问题，它还协助 I/O 调度算法实现了 IO